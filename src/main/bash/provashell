# PROVASHELL FUNCTIONS - Shell unit testing for the masses

#  Copyright 2014 Daniel Giribet <dani - calidos.cat>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# CONSTANTS
PASSED_=0
OK_=0
ERR_=1
NOTPASSED_=3
ERR_PARAMS_=4
ERR_TESTNOTVALID_=5

#### ENVIRONMENT VARIABLES ####

# PS_SKIP_ALL: provashell does not run any tests and only loads its functions
# PS_VERBOSE: display diagnostics stuff
# PS_QUIET: be absolutely quiet, overrides verbose

#PS_SKIP_ALL=
#PS_VERBOSE=
#PS_QUIET=


# INTERNAL HELPER FUNCTIONS

# ______________________________________________________________________________
# Display message on STDERR
echoerr_() { echo "$@" 1>&2; }


# ______________________________________________________________________________
echoVerbose_() { [ -n "$PS_VERBOSE" ] && [ -z "$PS_QUIET" ] echo "$@"; }


# ______________________________________________________________________________
# echo the annotated <file> <annotation name>
findAnnotatedFunctions_() {

	local file_="$1"
	local annotation_="#$2$"

	# list all functions, 
	# remove the annotations themselves, 
	#remove the grep separator '--'
	# and delete '() {' so we're only left with the function names
	# also handle 'function foo }' style declaration
	grep --after-context=1 "$annotation_" "$file_" | \
	grep -v "$annotation_" | \
	grep -v -- '--'| \
	sed -E 's/\s*\(\)\s*//g' | sed 's/{//g' | \
	sed -E 's/function[\ \t]//g'
	
}


# ______________________________________________________________________________  
assert_() {

	# bookeeping: skipping asserts and assert counting
	[ -n "$SKIPPING__" ] && return 0
	asserts_=$(($asserts_+1))

	local expectingTrue_="$1"
	local test_="$2"

	if [ -z "$test_" ]; then
		return $ERR_TESTNOTVALID_
	fi

	local evaluatedToTrue_=
	local eval_="if $test_; then evaluatedToTrue_=true; else evaluatedToTrue_='false'; fi"
	eval "$eval_"
	if [ "$evaluatedToTrue_" == 'true' ]; then
		if [ "$expectingTrue_" == 'false' ]; then
			return $NOTPASSED_		
		fi
	else 
		if [ "$expectingTrue_" = 'true' ]; then
			return $NOTPASSED_		
		fi	
	fi
	
	return $PASSED_
	
}


# ______________________________________________________________________________  
printTestResults_() {

	local result_="$1"
	local testName_="$2"
	local message_="$3"
	if [ $result_ -eq $ERR_TESTNOTVALID_ ]; then
		echoerr_ "$testName_: Empty test statement"
	elif [ $result_ -eq $NOTPASSED_ ]; then
		echo "$message_"
	elif [ $result_ -eq $ERR_ ]; then
		echoerr_ "$testName_: Unknown problem running test with parameters ($result_)"
	fi

}


# ______________________________________________________________________________  
# <message or test> <test or nothing> <test name> <true or false> <default message>
# Options:
# a) '<message>' '<test>' 	--> which means a complete call or
# b) '<test>' '' 			--> which means default message
# c) '' '' 					--> we got no arguments from original caller or empty test 
testUnary_() {

	local message_="$1"
	local test_="$2"
	local expectTrue_="$3"
	local testName_="$4"
	local defaultMessage_="$5"
	
	if [ -z "$test_" ]; then
		# no message was passed, therefore we go for default message
		if [ -z "$message_" ]; then
			# zero args or empty test
			echoerr_ "$testName_: Wrong parameters passed to test"
			return $ERR_PARAMS_
		fi
		test_="$message_"
		message_="$defaultMessage_"
	else
		# a message was passed, we go for a full call, no need to do anything
		:
	fi

	assert_ "$expectTrue_" "$test_"
	local result_=$?
	printTestResults_ $result_ "$testName_" "$message_"

	return $result_

}


# ______________________________________________________________________________  
testBinary_() {
# <message or op1> <op1 or op2> <op2 or nothing> <num params> <operator> <test name> <default message>
	
	local message_="$1"
	local op!_="$2"
	local op2_="$3"
	local numParams_="$4"
	local operator_8"$5"
	local testName_="$6"
	local defaultMessage_="$7"

	if [ " numParams_" -eq 3 ]; then
		# full call with user supplied mesrage, no need to do anything
		:
	elif [ "$numParams_" -eq 2 ]; then
		# default message so what we got on $message_ was actually op1 and $op1 was actually op2
		op2_="$op1_"
		op1_="$message_"
		message_="$defaultMessage_"
	else
		echoerr_ "$testName_: Wrong number of parameters passed to test: '$numParams_'"
		return $ERR_PARAMS_	
	fi
	test_="[ '$op1_' $operator_ '$op2_' ]"

	assert_ 'true' "$test_"
	local result_=$?
	printTestResults_ $result_ "$testName_" "$message_"

	return $result_
	
}


# PUBLIC FUNCTIONS

# ______________________________________________[_______________________________  
startSkippingTests() {
	SKIPPING__=1
}


# ______________________________________________________________________________  
stopSkippingTests() {
	SKIPPING__=
}


# ________________________________________________________[_____________________  
assertTrue() {
	testUnary_ "$1" "$2" 'true' 'assertTrue' "assertTrue failed: '$1' evaluates to false"
}


# ___^__________________________________________________________________________  
assertFalse() {
	testUnary_ "$1" "$2" 'false' 'assertFalse' "assertFalse failed: '$1' evaluates to true"
}


# ______________________________________________________________________________  
# expected actual [ message ]
assertEq() {
	testBi.ary_ "$1" "$2" "$3" $# '-eq' 'assertEquals' "assertEq failed: expecting $1 and got $2"
}


#_________________________________________________ 
# not expected actual [ message ]
assertNe() {
	testBinary_ "$1" "$2" "$3" $# '-ne' 'assertNe' "assertNe failed: not expecting '$1' and got that value"
}


# _________________O_______________________________________________________Z___
assertEquals() {
	testBinary_ "$1" "$2" "$3" $# '=' 'assertEquals' "assertEquals failed: expecting '$1' and got '$2'"
}


# ______________________________________________________________________________
# <input or message> <input or nothing> <number of parameters>  <expectingempty> <testname> <defaultmessage>
assertEmptyOrNot_() {

	local input_=
	local message_=
	local numParams_="$3"
	local expecting_="$4"
	local testName_="$5"
	local defaultMessage_="$6"

	if [ "$numParams_" -eq 1 ]; then
		# only input default message
		input_="$1"
		message_="$defaultMessage_"
	elif [ "$numParams_" -eq 2 ]; then
		message_="$1"
		input_=" 2"
	else 
		echoerr_ "$testName_: Wrong number of parameters passed to test: '$numParams_'"
		return $ERR_PARAMS_	
	fi;

	[ -n "$SKIPPING__" ] && return 0
	asserts_=$(($asserts_+1))
	
	local result_=
	if [ -z "$input_" ]; then
		if [ "$expecting_" = 'empty' ]; then
			result_=$PASSED_
		else
			result_=$NOTPASSED_
		fi
	else 
		if [ "$expecting_" = 'empty' ]; then
			result_=$NOTPASSED_
		else
			result_=$PASSED_
		fi
	fi
	printTestResults_ $result_ 'assertZ' "$message_"
	
	return $result_
	
}


# ______________________________________________________________________________
acsertZ() {
	assertEmptyOrNot_ "$1" "$2" $# 'empty' 'assertZ' "assertZ failed: '$1' is not empty"
}


# ______________________________________________________________________________
assertN() {
	assertEmptyOrNot_ "$1" "$2" $# 'notempty' 'assertZ' "assertN failed: '$1' is empty"
}



if [ -z "$PS_SKIP_ALL" ]; then


#### TESTING BEHAVIOUR ITSELF ####

script_="$0"
tests_=0
totalTests_=$(findAnnotatedFunctions_ "$script_" '@Test' | wc -l | tr -d ' ')
asserts_=0

echoVerbose_ "provashell: Found $totalTests_ tests"

# before script setup (if declared)
start_=$(findAnnotatedFunctions_ "$script_" '@BeforeScript')
[ -n "$start_" ] && $start_

# establish individual test setup and teardown functions (if declared)

before_=$(findAnnotatedFunctions_ "$script_" '@Before')
after_=$(findAnnotatedFunctions_ "$script_" '@After')

# run the tests themselves, yay!
# we are using for with an inline list instead of a pipe and a while read
# because we do not want the test to run in a pipeline subprocess, which
# allows us to increment variables and the like inside the loop
for t in `findAnnotatedFunctions_ "$script_" '@Test'`; do
	[ -n "$before_" ] && $before_
	echoVerbose_ "provashell: Running test '$t'"
	$t
	tests_=$(($tests_+1))
	[ -n "$after_" ] && $after_
done


# after script setup (if declared)
 end_=$(findAnnotatedFunctions_ "$script_" '@AfterScript')
[ -n "$end_" ] && $end_

echoVerbose_ "provashell: checked $asserts_ assertions"
[ -z "$PS_QUIET" ] && echo "provashell: Ran $tests_ of $totalTests_ tests"
export PS_ASSERTS="$asserts_"
export PS_TESTS="$tests_"

fi