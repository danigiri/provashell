# PROVASHELL FUNCTIONS - Shell unit testing for the masses

#  Copyright 2014 Daniel Giribet <dani - calidos.cat>
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# CONSTANTS
PASSED_=0
OK_=0
ERR_=1
NOTPASSED_=3
ERR_PARAMS_=4
ERR_TESTNOTVALID_=5

#### ENVIRONMENT VARIABLES ####

# PS_SKIP_ALL: provashell does not run any tests and only loads its functions
# PS_VERBOSE: display diagnostics stuff
# PS_QUIET: be absolutely quiet, overrides verbose

#PS_SKIP_ALL=
#PS_VERBOSE=
#PS_QUIET=


# INTERNAL HELPER FUNCTIONS

# ______________________________________________________________________________
# Display message on STDERR
echoerr_() { echo "$@" 1>&2; }


# ______________________________________________________________________________
echoVerbose_() { [ -n "$PS_VERBOSE" ] && [ -z "$PS_QUIET" ] echo "$@"; }


# ______________________________________________________________________________
# echo the annotated <file> <annotation name>
findAnnotatedFunctions_() {

	local file_="$1"
	local annotation_="#$2$"

	# list all functions, 
	# remove the annotations themselves, 
	#remove the grep separator '--'
	# and delete '() {' so we're only left with the function names
	# also handle 'function foo }' style declaration
	grep --after-context=1 "$annotation_" "$file_" | \
	grep -v "$annotation_" | \
	grep -v -- '--'| \
	sed -E 's/\s*\(\)\s*//g' | sed 's/{//g' | \
	sed -E 's/function[\ \t]//g'
	
}


# ______________________________________________________________________________  
assert_() {

	# bookeeping: skipping asserts and assert counting
	[ -n "$SKIPPING__" ] && return 0
	asserts_=$(($asserts_+1))

	local expectingTrue_="$1"
	local test_="$2"

	if [ -z "$test_" ]; then
		return $ERR_TESTNOTVALID_
	fi

	local evaluatedToTrue_=
	local eval_="if $test_; then evaluatedToTrue_=true; else evaluatedToTrue_='false'; fi"
	eval "$eval_"
	if [ "$evaluatedToTrue_" == 'true' ]; then
		if [ "$expectingTrue_" == 'false' ]; then
			return $NOTPASSED_		
		fi
	else 
		if [ "$expectingTrue_" = 'true' ]; then
			return $NOTPASSED_		
		fi	
	fi
	
	return $PASSED_
	
}


# ______________________________________________________________________________  
printTestResults_() {

	local result_="$1"
	local testName_="$2"
	local message_="$3"
	if [ $result_ -eq $ERR_TESTNOTVALID_ ]; then
		echoerr_ "$testName_: Empty test statement"
	elif [ $result_ -eq $NOTPASSED_ ]; then
		echo "$message_"
	elif [ $result_ -eq $ERR_ ]; then
		echoerr_ "$testName_: Unknown problem running test with parameters: '$@'"
	fi

}


# ______________________________________________________________________________  
# <message or test> <test or nothing> <test name> <default message>
# Options:
# a) '<message>' '<test>' 	--> which means a complete call or
# b) '<test>' '' 			--> which means default message
# c) '' '' 					--> we got no arguments from original caller or empty test 
checkMsgAndExpr_() {

	message_="$1"
	test_="$2"
	local testName_="$3"
	local defaultMessage_="$4"
	
	if [ -z "$test_" ]; then
		# no message was passed, therefore we go for default message
		if [ -z "$message_" ]; then
			# zero args or empty test
			echoerr_ "$testName_: Wrong parameters passed to test"
			return $ERR_PARAMS_
		fi
		test_="$message_"
		message_="$defaultMessage_"
	else
		# a message was passed, we go for a full call, no need to do anything
		:
	fi
	return $OK_
}


# ______________________________________________________________________________  
testBinary_() {
# <message or op1> <op1 or op2> <op2 or nothing> <num params> <operator> <test name> <default message>
	
	message_="$1"
	local op1_="$2"
	local op2_="$3"
	local numParams_="$4"
	local operator_="$5"
	local testName_="$6"
	local defaultMessage_="$7"

	if [ "$numParams_" -eq 3 ]; then
		# full call with user supplied message, no need to do anything
		:
	elif [ "$numParams_" -eq 2 ]; then
		# default message so what we got on $message_ was actually op1 and $op1 was actually op2
		op2_="$op1_"
		op1_="$message_"
		message_="$defaultMessage_"
	else
		echoerr_ "$testName_: Wrong number of parameters passed to test: '$numParams_'"
		return $ERR_PARAMS_	
	fi
	test_="[ '$op1_' $operator_ '$op2_' ]"

	assert_ 'true' "$test_"
	local result_=$?
	printTestResults_ $result_ "$testName_" "$message_"

	return $result_
	
}


# PUBLIC FUNCTIONS

# ______________________________________________________________________________  
startSkippingTests() {
	SKIPPING__=1
}


# ______________________________________________________________________________  
stopSkippingTests() {
	SKIPPING__=
}


# ______________________________________________________________________________  
assertTrue() {
	
	local test_=''
	local message_=''
	
	checkMsgAndExpr_ "$1" "$2" 'assertTrue' "assertTrue failed: '$1' evaluates to false"
	result_=$?
	[ $result_ -ne $OK_ ] && return $result_
	
	assert_ 'true' "$test_"
	result_=$?
	printTestResults_ $result_ 'assertTrue' "$message_"

	return $result_
	
}


# ______________________________________________________________________________  
assertFalse() {

	local test_=''
	local message_=''
	
	checkMsgAndExpr_ "$1" "$2" 'assertFalse' "assertFalse failed: '$1' evaluates to true"
	local result_=$?
	[ $result_ -ne $OK_ ] && return $result_
		
	assert_ 'false' "$test_"
	result_=$?
	printTestResults_ $result_ 'assertFalse' "$message_"

	return $result_
	
}


# ______________________________________________________________________________  
# expected actual [ message ]
assertEq() {
	testBinary_ "$1" "$2" "$3" $# '-eq' 'assertEquals' "assertEq failed: expecting $1 and got $2"
}


#_________________________________________________ 
# not expected actual [ message ]
assertNe() {
	testBinary_ "$1" "$2" "$3" $# '-ne' 'assertNe' "assertNe failed: not expecting $1 and got that value"
}



# ______________________________________________________________________________
assertEquals() {
	testBinary_ "$1" "$2" "$3" $# '=' 'assertEquals' "assertEquals failed: expecting $1 and got $2"
}




if [ -z "$PS_SKIP_ALL" ]; then


#### TESTING BEHAVIOUR ITSELF ####

script_="$0"
tests_=0
totalTests_=$(findAnnotatedFunctions_ "$script_" '@Test' | wc -l | tr -d ' ')
asserts_=0

echoVerbose_ "provashell: Found $totalTests_ tests"

# before script setup (if declared)
start_=$(findAnnotatedFunctions_ "$script_" '@BeforeScript')
[ -n "$start_" ] && $start_

# establish individual test setup and teardown functions (if declared)

before_=$(findAnnotatedFunctions_ "$script_" '@Before')
after_=$(findAnnotatedFunctions_ "$script_" '@After')

# run the tests themselves, yay!
# we are using for with an inline list instead of a pipe and a while read
# because we do not want the test to run in a pipeline subprocess, which
# allows us to increment variables and the like inside the loop
for t in `findAnnotatedFunctions_ "$script_" '@Test'`; do
	[ -n "$before_" ] && $before_
	echoVerbose_ "provashell: Running test '$t'"
	$t
	tests_=$(($tests_+1))
	[ -n "$after_" ] && $after_
done


# after script setup (if declared)
 end_=$(findAnnotatedFunctions_ "$script_" '@AfterScript')
[ -n "$end_" ] && $end_

echoVerbose_ "provashell: checked $asserts_ assertions"
[ -z "$PS_QUIET" ] && echo "provashell: Ran $tests_ of $totalTests_ tests"
export PS_ASSERTS="$asserts_"
export PS_TESTS="$tests_"

fi